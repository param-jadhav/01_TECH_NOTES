It is absolutely possible to implement this. What you are describing is a Non-Blocking Retry Pattern using Dead Letter Topics (DLT).
Since you want to avoid annotations and prevent blocking the main queue, the best approach is to use a Custom Error Handler and a Destination Topic Resolver. This allows you to programmatically route failed messages to specific topics based on the retry attempt.
The Design: Multi-Tiered Non-Blocking Retry
To achieve your specific timing (5 seconds \rightarrow 15 minutes \rightarrow 1 hour \rightarrow 1 day), you should use a series of "Retry Topics" before the message hits the final "Parking Lot" DLT.
 * Main Topic: Processes the message. If a ResourceAccessException or DatabaseDown occurs, the error handler catches it.
 * Retry Topics: Instead of one DLT, you have Topic-Retry-5s, Topic-Retry-15m, etc.
 * Delay Mechanism: You use a Header-based delay. Since Kafka doesn't natively "pause" a message, your consumer for the retry topics will check the message timestamp and wait (sleep or back off) before processing, or use a tool like Spring Kafka's DefaultErrorHandler with a custom FixedBackOff.
Prompt for Your Coding Agent
You can copy and paste the following prompt into your coding assistant (like GitHub Copilot, Cursor, or ChatGPT) to generate the implementation.
> Role: Senior Java Engineer / Kafka Expert
> Task: Implement a non-blocking retry mechanism for a Kafka consumer using Spring Kafka without using @RetryableTopic annotations.
> Requirements:
>  * Manual Configuration: Use a ConcurrentKafkaListenerContainerFactory and a DefaultErrorHandler.
>  * Logic: If a database or resource exception occurs, the message must be sent to a retry topic.
>  * Non-Blocking: Do not block the main queue. The main consumer should move to the next message immediately after the failed message is sent to the retry topic.
>  * Progressive Backoff Schedule: Implement a custom DestinationTopicResolver or a manual routing logic to move messages through this specific sequence:
>    * Retry 1: 5 seconds delay
>    * Retry 2: 15 minutes delay
>    * Retry 3: 1 hour delay
>    * Retry 4: 1 day delay
>  * Reliability: Since auto-commit is true, ensure the error handler sends the message to the retry topic before the offset is committed for the failed record.
>  * Implementation Detail: Please provide the Java configuration for the DefaultErrorHandler and the DeadLetterPublishingRecoverer that calculates the destination topic based on a "retry-count" header.
> 
How it works (The Logic)
 * The Recoverer: When the code fails, the DeadLetterPublishingRecoverer is triggered. We override it to look at the message headers.
 * The Headers: We'll add a custom header like x-retry-count.
   * If count is 0 \rightarrow Send to retry-5s-topic.
   * If count is 1 \rightarrow Send to retry-15m-topic.
 * The Delayed Consumers: Each retry topic has its own listener. These listeners are configured with a backOff period. Because they are on separate topics, your main production queue stays at 100\% speed.
Why this is better than your current setup:
 * No Data Loss: Even with auto-commit=true, the error handler intercepts the failure and pushes the message to safety (the retry topic) before the loop continues.
 * Resource Friendly: By using separate topics for 1-hour or 1-day retries, you don't clog up memory with "waiting" messages.
Would you like me to generate the specific Java configuration code for this DefaultErrorHandler right now?
